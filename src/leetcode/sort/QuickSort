//Quick sort
check base condition. if element number is 0/1 we consider the array to be sorted
do partition for the element in the starting index, which gives us the pivot element position
recursive call quicksort for start to pivot-1 & pivot+1 to end.
//partition logic
    1. take start element as pivot element
    2. find the pivot index by counting how many elements are smaller than the pivot element
    3. start index+count should give us the right index to place the pivot element.
    4. Swap the pivot element to its correct position
    5. Ensure all left elements are less than pivot element and vice versa

class Solution {
    public int[] sortArray(int[] nums) {
        int start =0;
        int end =nums.length-1;

        quickSort(nums, start, end);

        return nums;
    }

    private void quickSort(int[] nums, int start, int end){
        //Base condition
        if (start>= end)
            return;

        //Call to place the starting element in the correct position and ensure all the elements left to it are small and vice versa.
        int pivotIndex=getPivotIndex(nums, start, end);

        //Recursively call the left part of the array
        quickSort(nums, start, pivotIndex-1);

        //Recursively call the right part of the array
        quickSort(nums, pivotIndex+1, end);
    }

    private int getPivotIndex(int[] nums, int start, int end){
        // Assuming the first element to be the pivot element
        int pivotElement = nums[start];

        //Count the no of elements smaller than the pivot element towards the right
        int count=0;
        for(int i=start+1;i<=end;i++){
            if (nums[i]<=pivotElement){
                count++;
            }
        }

        int pivotIndex=start+count;

        //Swap the pivot element to the correct position
        int temp = nums[pivotIndex];
        nums[pivotIndex] = pivotElement;
        nums[start]=temp;

        //Ensure all element left of the pivotElement are small and right are large
        int i=start;
        int j=end;
        while(i<pivotIndex && j>pivotIndex){
            if(nums[i]<=pivotElement){
                i++;
                continue;
            }
            if(nums[j]>pivotElement){
                j--;
                continue;
            }
            temp = nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
            i++;
            j--;

        }
        return pivotIndex;
    }
}
